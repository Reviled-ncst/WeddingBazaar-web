<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Booking Calendar Optimization Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        #logs {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            border: 1px solid #dee2e6;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #dee2e6;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .metric-label {
            font-size: 14px;
            color: #6c757d;
            margin-top: 5px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        button:disabled { 
            background: #6c757d; 
            cursor: not-allowed; 
        }
    </style>
</head>
<body>
    <h1>üöÄ Wedding Bazaar - Calendar API Optimization Test</h1>
    
    <div class="test-section">
        <h2>üìä Performance Metrics</h2>
        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value" id="totalRequests">0</div>
                <div class="metric-label">Total API Calls</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="uniqueRequests">0</div>
                <div class="metric-label">Unique Requests</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="cacheHits">0</div>
                <div class="metric-label">Cache Hits</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="apiTime">0ms</div>
                <div class="metric-label">Total API Time</div>
            </div>
        </div>
    </div>

    <div class="test-section">
        <h2>üß™ Test Controls</h2>
        <button onclick="testSingleVendorLoad()">Test Single Vendor Load</button>
        <button onclick="testRapidCalendarNavigation()">Test Rapid Navigation</button>
        <button onclick="testMultipleVendorSwitching()">Test Vendor Switching</button>
        <button onclick="testCacheEfficiency()">Test Cache Efficiency</button>
        <button onclick="clearLogs()">Clear Logs</button>
        <button onclick="clearAllMetrics()">Reset Metrics</button>
    </div>

    <div class="test-section">
        <h2>üìã Test Results & Logs</h2>
        <div id="logs"></div>
    </div>

    <script>
        // Test configuration
        const API_URL = 'https://weddingbazaar-web.onrender.com';
        const TEST_VENDOR_ID = '2-2025-003'; // Known vendor with data
        
        // Metrics tracking
        let metrics = {
            totalRequests: 0,
            uniqueRequests: new Set(),
            cacheHits: 0,
            apiStartTime: 0,
            totalApiTime: 0
        };

        // Logging function
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('logs');
            const logEntry = `[${timestamp}] ${message}\n`;
            logElement.textContent += logEntry;
            logElement.scrollTop = logElement.scrollHeight;
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // Update metrics display
        function updateMetrics() {
            document.getElementById('totalRequests').textContent = metrics.totalRequests;
            document.getElementById('uniqueRequests').textContent = metrics.uniqueRequests.size;
            document.getElementById('cacheHits').textContent = metrics.cacheHits;
            document.getElementById('apiTime').textContent = `${metrics.totalApiTime}ms`;
        }

        // Monitor network requests (simplified approach)
        let originalFetch = window.fetch;
        window.fetch = function(...args) {
            const url = args[0];
            if (typeof url === 'string' && url.includes('/api/')) {
                metrics.totalRequests++;
                metrics.uniqueRequests.add(url);
                
                const startTime = Date.now();
                log(`üåê API Request: ${url}`, 'info');
                
                return originalFetch.apply(this, args).then(response => {
                    const endTime = Date.now();
                    const duration = endTime - startTime;
                    metrics.totalApiTime += duration;
                    
                    log(`‚úÖ API Response: ${response.status} (${duration}ms)`, 'success');
                    updateMetrics();
                    return response;
                }).catch(error => {
                    const endTime = Date.now();
                    const duration = endTime - startTime;
                    metrics.totalApiTime += duration;
                    
                    log(`‚ùå API Error: ${error.message} (${duration}ms)`, 'error');
                    updateMetrics();
                    throw error;
                });
            }
            return originalFetch.apply(this, args);
        };

        // Test functions
        async function testSingleVendorLoad() {
            log('üî¨ Starting Single Vendor Load Test...', 'info');
            
            const startMetrics = { ...metrics };
            
            try {
                // Simulate loading calendar for a vendor (42 days)
                const currentDate = new Date();
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();
                const firstDay = new Date(year, month, 1);
                const calendarStartDate = new Date(firstDay);
                calendarStartDate.setDate(calendarStartDate.getDate() - firstDay.getDay());
                
                const calendarEndDate = new Date(calendarStartDate);
                calendarEndDate.setDate(calendarEndDate.getDate() + 41);
                
                const startStr = calendarStartDate.toISOString().split('T')[0];
                const endStr = calendarEndDate.toISOString().split('T')[0];
                
                log(`üìÖ Testing availability for ${TEST_VENDOR_ID} from ${startStr} to ${endStr}`, 'info');
                
                // Test multiple rapid calls (simulating React re-renders)
                const promises = [];
                for (let i = 0; i < 3; i++) {
                    promises.push(fetch(`${API_URL}/api/vendors/${TEST_VENDOR_ID}/off-days`));
                    promises.push(fetch(`${API_URL}/api/bookings/vendor/2?startDate=${startStr}&endDate=${endStr}`));
                }
                
                await Promise.all(promises);
                
                const requestsUsed = metrics.totalRequests - startMetrics.totalRequests;
                const timeUsed = metrics.totalApiTime - startMetrics.totalApiTime;
                
                if (requestsUsed <= 6) {
                    log(`‚úÖ EXCELLENT: Only ${requestsUsed} API calls made (expected 6 for bulk load)`, 'success');
                } else if (requestsUsed <= 12) {
                    log(`‚ö†Ô∏è GOOD: ${requestsUsed} API calls made (some optimization working)`, 'warning');
                } else {
                    log(`‚ùå POOR: ${requestsUsed} API calls made (optimization may not be working)`, 'error');
                }
                
                log(`‚è±Ô∏è Total time: ${timeUsed}ms`, 'info');
                
            } catch (error) {
                log(`‚ùå Test failed: ${error.message}`, 'error');
            }
        }

        async function testRapidCalendarNavigation() {
            log('üî¨ Starting Rapid Calendar Navigation Test...', 'info');
            
            const startMetrics = { ...metrics };
            
            try {
                // Simulate rapid month navigation (should use cache after first load)
                const dates = [];
                const baseDate = new Date();
                
                for (let i = -2; i <= 2; i++) {
                    const testDate = new Date(baseDate);
                    testDate.setMonth(testDate.getMonth() + i);
                    dates.push(testDate);
                }
                
                // First pass - should make API calls
                log('üìÖ First navigation pass (should make API calls)...', 'info');
                for (const date of dates) {
                    const year = date.getFullYear();
                    const month = date.getMonth();
                    const firstDay = new Date(year, month, 1);
                    const startDate = new Date(firstDay);
                    startDate.setDate(startDate.getDate() - firstDay.getDay());
                    const endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + 41);
                    
                    const startStr = startDate.toISOString().split('T')[0];
                    const endStr = endDate.toISOString().split('T')[0];
                    
                    await fetch(`${API_URL}/api/vendors/${TEST_VENDOR_ID}/off-days`);
                    await fetch(`${API_URL}/api/bookings/vendor/2?startDate=${startStr}&endDate=${endStr}`);
                    
                    // Small delay to simulate user interaction
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                const firstPassRequests = metrics.totalRequests - startMetrics.totalRequests;
                log(`üìä First pass used ${firstPassRequests} API calls`, 'info');
                
                // Second pass - should use cache (simulate going back to same months)
                log('üìÖ Second navigation pass (should use cache)...', 'info');
                const secondPassStart = metrics.totalRequests;
                
                for (const date of dates.slice().reverse()) {
                    const year = date.getFullYear();
                    const month = date.getMonth();
                    const firstDay = new Date(year, month, 1);
                    const startDate = new Date(firstDay);
                    startDate.setDate(startDate.getDate() - firstDay.getDay());
                    const endDate = new Date(startDate);
                    endDate.setDate(endDate.getDate() + 41);
                    
                    const startStr = startDate.toISOString().split('T')[0];
                    const endStr = endDate.toISOString().split('T')[0];
                    
                    await fetch(`${API_URL}/api/vendors/${TEST_VENDOR_ID}/off-days`);
                    await fetch(`${API_URL}/api/bookings/vendor/2?startDate=${startStr}&endDate=${endStr}`);
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                const secondPassRequests = metrics.totalRequests - secondPassStart;
                
                if (secondPassRequests === 0) {
                    log(`‚úÖ PERFECT: Second pass used 0 API calls (100% cache hit rate)`, 'success');
                } else if (secondPassRequests < firstPassRequests / 2) {
                    log(`‚úÖ GOOD: Second pass used ${secondPassRequests} API calls (cache working)`, 'success');
                } else {
                    log(`‚ö†Ô∏è POOR: Second pass used ${secondPassRequests} API calls (cache may not be working)`, 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Test failed: ${error.message}`, 'error');
            }
        }

        async function testMultipleVendorSwitching() {
            log('üî¨ Starting Multiple Vendor Switching Test...', 'info');
            
            const vendors = ['2-2025-003', '2-2025-001', '2-2025-002'];
            const startMetrics = { ...metrics };
            
            try {
                const currentDate = new Date();
                const startStr = currentDate.toISOString().split('T')[0];
                const endDate = new Date(currentDate);
                endDate.setDate(endDate.getDate() + 30);
                const endStr = endDate.toISOString().split('T')[0];
                
                for (const vendorId of vendors) {
                    log(`üë§ Testing vendor: ${vendorId}`, 'info');
                    
                    const bookingVendorId = vendorId.split('-')[0]; // Extract booking ID
                    
                    await Promise.all([
                        fetch(`${API_URL}/api/vendors/${vendorId}/off-days`),
                        fetch(`${API_URL}/api/bookings/vendor/${bookingVendorId}?startDate=${startStr}&endDate=${endStr}`)
                    ]);
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                const requestsUsed = metrics.totalRequests - startMetrics.totalRequests;
                log(`üìä Vendor switching used ${requestsUsed} API calls for ${vendors.length} vendors`, 'info');
                
                if (requestsUsed <= vendors.length * 2) {
                    log(`‚úÖ EXCELLENT: Efficient vendor switching (${requestsUsed / vendors.length} calls per vendor)`, 'success');
                } else {
                    log(`‚ö†Ô∏è POOR: Inefficient vendor switching (${requestsUsed / vendors.length} calls per vendor)`, 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Test failed: ${error.message}`, 'error');
            }
        }

        async function testCacheEfficiency() {
            log('üî¨ Starting Cache Efficiency Test...', 'info');
            
            const startMetrics = { ...metrics };
            
            try {
                const testUrl = `${API_URL}/api/vendors/${TEST_VENDOR_ID}/off-days`;
                
                // Make 5 identical requests rapidly
                log('üì° Making 5 identical requests rapidly...', 'info');
                const promises = [];
                for (let i = 0; i < 5; i++) {
                    promises.push(fetch(testUrl));
                }
                
                await Promise.all(promises);
                
                const requestsUsed = metrics.totalRequests - startMetrics.totalRequests;
                
                if (requestsUsed === 1) {
                    log(`‚úÖ PERFECT: Only 1 API call made for 5 identical requests (request deduplication working)`, 'success');
                } else if (requestsUsed <= 2) {
                    log(`‚úÖ GOOD: ${requestsUsed} API calls made for 5 requests (some deduplication working)`, 'success');
                } else if (requestsUsed < 5) {
                    log(`‚ö†Ô∏è OK: ${requestsUsed} API calls made for 5 requests (partial optimization)`, 'warning');
                } else {
                    log(`‚ùå POOR: ${requestsUsed} API calls made for 5 requests (no optimization)`, 'error');
                }
                
            } catch (error) {
                log(`‚ùå Test failed: ${error.message}`, 'error');
            }
        }

        function clearLogs() {
            document.getElementById('logs').textContent = '';
            log('üßπ Logs cleared', 'info');
        }

        function clearAllMetrics() {
            metrics = {
                totalRequests: 0,
                uniqueRequests: new Set(),
                cacheHits: 0,
                apiStartTime: 0,
                totalApiTime: 0
            };
            updateMetrics();
            log('üîÑ Metrics reset', 'info');
        }

        // Initialize
        log('üöÄ Calendar Optimization Test Ready', 'info');
        log(`üîó Testing against: ${API_URL}`, 'info');
        log(`üë§ Using test vendor: ${TEST_VENDOR_ID}`, 'info');
        updateMetrics();
    </script>
</body>
</html>
