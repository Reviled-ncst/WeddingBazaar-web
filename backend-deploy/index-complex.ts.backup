import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import { config } from 'dotenv';
import { db, testDatabaseConnection } from './backend/database/connection';
import { VendorService } from './backend/services/vendorService';
import { BookingService } from './backend/services/bookingService';
import { AuthService } from './backend/services/authService';
import { MockAuthService } from './backend/services/mockAuthService';
import { messagingService } from './backend/services/messagingService';
import { servicesService } from './backend/services/servicesService';
import { reviewsService } from './backend/services/reviewsService';
import { userProfileService } from './backend/services/userProfileService';
import { ImageProxyService } from './backend/services/imageProxyService';
import vendorRoutes from './backend/api/vendors/routes';
import bookingRoutes from './backend/api/bookings/routes';
import enhancedBookingRoutes from './backend/api/bookings/enhanced_routes';
import messagingRoutes from './backend/api/messaging/routes';
import paymentRoutes from './backend/api/payment/routes';
import subscriptionRoutes from './backend/api/subscriptions/routes';

// Debug imports
console.log('ðŸ“¦ Enhanced booking routes import type:', typeof enhancedBookingRoutes);
console.log('ðŸ“¦ Enhanced booking routes:', enhancedBookingRoutes ? 'Loaded' : 'Failed');

// Load environment variables
config();

const app = express();
const PORT = process.env.BACKEND_PORT || process.env.PORT || 3001;

// Middleware
app.use(helmet());

// CORS configuration with environment variable support
const corsOrigins = process.env.CORS_ORIGINS 
  ? process.env.CORS_ORIGINS.split(',').map(origin => origin.trim())
  : process.env.NODE_ENV === 'production' 
    ? ['https://yourdomain.com'] 
    : ['http://localhost:5173', 'http://localhost:3000'];

app.use(cors({
  origin: corsOrigins,
  credentials: true
}));
app.use(morgan('combined'));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Services
const vendorService = new VendorService();
const bookingService = new BookingService();
const authService = new AuthService();

// Health check endpoint
app.get('/api/health', async (req, res) => {
  try {
    const dbConnected = await testDatabaseConnection();
    res.json({
      status: 'OK',
      timestamp: new Date().toISOString(),
      database: dbConnected ? 'Connected' : 'Disconnected',
      environment: process.env.NODE_ENV || 'development'
    });
  } catch (error) {
    res.status(500).json({
      status: 'Error',
      message: 'Health check failed',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// API Routes
console.log('ðŸ”— Registering enhanced booking routes at /api/bookings/enhanced');
app.use('/api/vendors', vendorRoutes);
app.use('/api/bookings/enhanced', enhancedBookingRoutes);
app.use('/api/bookings', bookingRoutes);
app.use('/api/messaging', messagingRoutes);
app.use('/api/payment', paymentRoutes);
app.use('/api/subscriptions', subscriptionRoutes);

// Image proxy route for handling CORS issues with external images
app.get('/api/image-proxy', ImageProxyService.proxyImage);

console.log('âœ… All routes registered');

// Add a direct conversations endpoint for compatibility
app.post('/api/conversations', async (req, res) => {
  try {
    const { vendorName, serviceName } = req.body;
    
    // Generate conversation ID
    const conversationId = `conv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    // For now, just return a success response
    // In a real app, you'd want to create the conversation in the database
    res.json({
      success: true,
      conversationId,
      message: 'Conversation created successfully'
    });
  } catch (error) {
    console.error('Error creating conversation:', error);
    res.status(500).json({ error: 'Failed to create conversation' });
  }
});

// Authentication endpoints
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({
        error: 'Email and password are required'
      });
    }

    const authResponse = await authService.login({ email, password });
    res.json(authResponse);
  } catch (error) {
    console.error('Login error:', error);
    res.status(401).json({
      error: 'Login failed',
      message: error instanceof Error ? error.message : 'Invalid credentials'
    });
  }
});

app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, firstName, lastName, role, phone } = req.body;

    if (!email || !password || !firstName || !lastName || !role) {
      return res.status(400).json({
        error: 'Email, password, firstName, lastName, and role are required'
      });
    }

    if (!['couple', 'vendor'].includes(role)) {
      return res.status(400).json({
        error: 'Role must be either "couple" or "vendor"'
      });
    }

    const authResponse = await authService.register({
      email,
      password,
      firstName,
      lastName,
      role,
      phone
    });

    res.status(201).json(authResponse);
  } catch (error) {
    console.error('Registration error:', error);
    res.status(400).json({
      error: 'Registration failed',
      message: error instanceof Error ? error.message : 'Registration error'
    });
  }
});

app.get('/api/auth/validate', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        error: 'No token provided'
      });
    }

    const token = authHeader.substring(7);
    const user = await authService.validateToken(token);
    
    res.json({ user });
  } catch (error) {
    console.error('Token validation error:', error);
    res.status(401).json({
      error: 'Invalid token',
      message: error instanceof Error ? error.message : 'Token validation failed'
    });
  }
});

// Token verification endpoint (for session persistence)
app.post('/api/auth/verify', async (req, res) => {
  try {
    const { token } = req.body;
    
    if (!token) {
      return res.status(401).json({
        error: 'No token provided'
      });
    }

    const user = await authService.validateToken(token);
    
    res.json({ user });
  } catch (error) {
    console.error('Token verification error:', error);
    res.status(401).json({
      error: 'Invalid token',
      message: error instanceof Error ? error.message : 'Token verification failed'
    });
  }
});

// User Profile endpoints
app.get('/api/users/profile/:userId', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        error: 'No token provided'
      });
    }

    const token = authHeader.substring(7);
    const user = await authService.validateToken(token);
    
    // Ensure user can only access their own profile
    if (user.id !== req.params.userId) {
      return res.status(403).json({
        error: 'Access denied'
      });
    }
    
    const userProfile = await userProfileService.getUserProfile(req.params.userId);
    
    res.json({
      success: true,
      user: userProfile
    });
  } catch (error) {
    console.error('Error fetching user profile:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch user profile',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.put('/api/users/profile/:userId', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        error: 'No token provided'
      });
    }

    const token = authHeader.substring(7);
    const user = await authService.validateToken(token);
    
    // Ensure user can only update their own profile
    if (user.id !== req.params.userId) {
      return res.status(403).json({
        error: 'Access denied'
      });
    }
    
    const updatedProfile = await userProfileService.updateUserProfile(req.params.userId, req.body);
    
    res.json({
      success: true,
      user: updatedProfile
    });
  } catch (error) {
    console.error('Error updating user profile:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update user profile',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Vendor endpoints
app.get('/api/vendors', async (req, res) => {
  try {
    const { business_type, search } = req.query;
    let vendors;

    if (search && typeof search === 'string') {
      vendors = await vendorService.searchVendors(search, {
        business_type: business_type as string
      });
    } else if (business_type && typeof business_type === 'string') {
      vendors = await vendorService.getVendorsByCategory(business_type);
    } else {
      vendors = await vendorService.getAllVendors();
    }

    res.json(vendors);
  } catch (error) {
    console.error('Error fetching vendors:', error);
    res.status(500).json({
      error: 'Failed to fetch vendors',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get vendor categories
app.get('/api/vendors/categories', async (req, res) => {
  try {
    // Mock vendor categories data
    const categories = [
      {
        id: 'photography',
        name: 'Photography',
        description: 'Professional wedding photographers',
        icon: 'ðŸ“¸',
        count: 45
      },
      {
        id: 'catering',
        name: 'Catering',
        description: 'Wedding catering services',
        icon: 'ðŸ½ï¸',
        count: 32
      },
      {
        id: 'venue',
        name: 'Venues',
        description: 'Wedding venues and locations',
        icon: 'ðŸ›ï¸',
        count: 28
      },
      {
        id: 'music',
        name: 'Music & Entertainment',
        description: 'DJs, bands, and entertainment',
        icon: 'ðŸŽµ',
        count: 22
      },
      {
        id: 'florals',
        name: 'Florals',
        description: 'Wedding flowers and decorations',
        icon: 'ðŸŒ¸',
        count: 18
      },
      {
        id: 'planning',
        name: 'Wedding Planning',
        description: 'Professional wedding planners',
        icon: 'ðŸ“‹',
        count: 15
      }
    ];

    res.json({ success: true, categories });
  } catch (error) {
    console.error('Error fetching vendor categories:', error);
    res.status(500).json({
      error: 'Failed to fetch vendor categories',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get featured vendors
app.get('/api/vendors/featured', async (req, res) => {
  try {
    const limit = req.query.limit ? parseInt(req.query.limit as string) : 6;
    
    // Mock featured vendors data
    const featuredVendors = [
      {
        id: 1,
        name: "Elite Wedding Photography",
        category: "photography",
        location: "Manila",
        rating: 4.9,
        price_range: "â‚±80,000 - â‚±150,000",
        image: "https://images.unsplash.com/photo-1606216794074-735e91aa2c92?w=400",
        featured: true
      },
      {
        id: 2,
        name: "Grandeur Catering Services",
        category: "catering",
        location: "Quezon City",
        rating: 4.8,
        price_range: "â‚±1,500 - â‚±3,000 per person",
        image: "https://images.unsplash.com/photo-1555244162-803834f70033?w=400",
        featured: true
      },
      {
        id: 3,
        name: "Paradise Garden Venue",
        category: "venue",
        location: "Tagaytay",
        rating: 4.9,
        price_range: "â‚±200,000 - â‚±500,000",
        image: "https://images.unsplash.com/photo-1519167758481-83f29c8498c5?w=400",
        featured: true
      },
      {
        id: 4,
        name: "Harmony Wedding Band",
        category: "music",
        location: "Makati",
        rating: 4.7,
        price_range: "â‚±50,000 - â‚±100,000",
        image: "https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=400",
        featured: true
      },
      {
        id: 5,
        name: "Bloom & Blossom Florists",
        category: "florals",
        location: "Pasig",
        rating: 4.8,
        price_range: "â‚±30,000 - â‚±80,000",
        image: "https://images.unsplash.com/photo-1578662996442-48f60103fc96?w=400",
        featured: true
      },
      {
        id: 6,
        name: "Perfect Day Planners",
        category: "planning",
        location: "BGC",
        rating: 4.9,
        price_range: "â‚±100,000 - â‚±300,000",
        image: "https://images.unsplash.com/photo-1511795409834-ef04bbd61622?w=400",
        featured: true
      }
    ];

    const limitedVendors = featuredVendors.slice(0, limit);
    res.json({ success: true, vendors: limitedVendors });
  } catch (error) {
    console.error('Error fetching featured vendors:', error);
    res.status(500).json({
      error: 'Failed to fetch featured vendors',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.get('/api/vendors/:id', async (req, res) => {
  try {
    const vendor = await vendorService.getVendorById(req.params.id);
    if (!vendor) {
      return res.status(404).json({ error: 'Vendor not found' });
    }
    res.json(vendor);
  } catch (error) {
    console.error('Error fetching vendor:', error);
    res.status(500).json({
      error: 'Failed to fetch vendor',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.post('/api/vendors', async (req, res) => {
  try {
    const vendor = await vendorService.createVendor(req.body);
    res.status(201).json(vendor);
  } catch (error) {
    console.error('Error creating vendor:', error);
    res.status(500).json({
      error: 'Failed to create vendor',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Services endpoints
app.get('/api/services', async (req, res) => {
  try {
    const params = {
      query: req.query.query as string,
      category: req.query.category as string,
      location: req.query.location as string,
      priceRange: req.query.priceRange as string,
      minRating: req.query.minRating ? Number(req.query.minRating) : undefined,
      sortBy: req.query.sortBy as string,
      page: req.query.page ? Number(req.query.page) : undefined,
      limit: req.query.limit ? Number(req.query.limit) : undefined
    };

    const result = await servicesService.getServices(params);
    res.json(result);
  } catch (error) {
    console.error('Error fetching services:', error);
    res.status(500).json({
      error: 'Failed to fetch services',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.get('/api/services/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const service = await servicesService.getServiceById(id);
    
    if (!service) {
      return res.status(404).json({
        error: 'Service not found'
      });
    }
    
    res.json(service);
  } catch (error) {
    console.error('Error fetching service:', error);
    res.status(500).json({
      error: 'Failed to fetch service',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.get('/api/services/vendor/:vendorId', async (req, res) => {
  try {
    const { vendorId } = req.params;
    const services = await servicesService.getServicesByVendor(vendorId);
    res.json(services);
  } catch (error) {
    console.error('Error fetching vendor services:', error);
    res.status(500).json({
      error: 'Failed to fetch vendor services',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.get('/api/services/search/:query', async (req, res) => {
  try {
    const { query } = req.params;
    const services = await servicesService.searchServices(query);
    res.json(services);
  } catch (error) {
    console.error('Error searching services:', error);
    res.status(500).json({
      error: 'Failed to search services',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// ============================================================================
// REVIEWS ENDPOINTS
// ============================================================================

app.get('/api/reviews', async (req, res) => {
  try {
    const { page = 1, limit = 20 } = req.query;
    const result = await reviewsService.getAllReviews(
      parseInt(page as string),
      parseInt(limit as string)
    );
    res.json(result);
  } catch (error) {
    console.error('Error fetching reviews:', error);
    res.status(500).json({
      error: 'Failed to fetch reviews',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.get('/api/reviews/service/:serviceId', async (req, res) => {
  try {
    const { serviceId } = req.params;
    const reviews = await reviewsService.getReviewsByServiceId(serviceId);
    res.json(reviews);
  } catch (error) {
    console.error('Error fetching service reviews:', error);
    res.status(500).json({
      error: 'Failed to fetch service reviews',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.get('/api/reviews/vendor/:vendorId', async (req, res) => {
  try {
    const { vendorId } = req.params;
    const reviews = await reviewsService.getReviewsByVendorId(vendorId);
    res.json(reviews);
  } catch (error) {
    console.error('Error fetching vendor reviews:', error);
    res.status(500).json({
      error: 'Failed to fetch vendor reviews',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// ============================================================================
// MESSAGING ENDPOINTS
// ============================================================================

// Messaging endpoints
app.get('/api/messages/conversations/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const conversations = await messagingService.getUserConversations(userId);
    res.json(conversations);
  } catch (error) {
    console.error('Error fetching conversations:', error);
    res.status(500).json({
      error: 'Failed to fetch conversations',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.get('/api/messages/conversation/:conversationId', async (req, res) => {
  try {
    const { conversationId } = req.params;
    const { limit = '50', offset = '0' } = req.query;
    
    const messages = await messagingService.getConversationMessages(
      conversationId, 
      parseInt(limit as string), 
      parseInt(offset as string)
    );
    res.json(messages);
  } catch (error) {
    console.error('Error fetching conversation messages:', error);
    res.status(500).json({
      error: 'Failed to fetch messages',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.post('/api/messages/send', async (req, res) => {
  try {
    const { conversationId, senderId, content, type, attachments } = req.body;

    if (!conversationId || !senderId || !content) {
      return res.status(400).json({
        error: 'conversationId, senderId, and content are required'
      });
    }

    const message = await messagingService.sendMessage({
      conversationId,
      senderId,
      content,
      type,
      attachments
    });

    res.status(201).json(message);
  } catch (error) {
    console.error('Error sending message:', error);
    res.status(500).json({
      error: 'Failed to send message',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.post('/api/messages/conversation', async (req, res) => {
  try {
    const { participants, initiatorId } = req.body;

    if (!participants || !Array.isArray(participants) || participants.length !== 2 || !initiatorId) {
      return res.status(400).json({
        error: 'participants (array of 2 user IDs) and initiatorId are required'
      });
    }

    const conversation = await messagingService.createConversation({
      participants,
      initiatorId
    });

    res.status(201).json(conversation);
  } catch (error) {
    console.error('Error creating conversation:', error);
    res.status(500).json({
      error: 'Failed to create conversation',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.patch('/api/messages/conversation/:conversationId/read', async (req, res) => {
  try {
    const { conversationId } = req.params;
    const { userId } = req.body;

    if (!userId) {
      return res.status(400).json({
        error: 'userId is required'
      });
    }

    await messagingService.markMessagesAsRead(conversationId, userId);
    res.json({ success: true });
  } catch (error) {
    console.error('Error marking messages as read:', error);
    res.status(500).json({
      error: 'Failed to mark messages as read',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Booking endpoints
app.get('/api/bookings', async (req, res) => {
  try {
    const bookings = await bookingService.getAllBookings();
    res.json(bookings);
  } catch (error) {
    console.error('Error fetching bookings:', error);
    res.status(500).json({
      error: 'Failed to fetch bookings',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

app.post('/api/bookings', async (req, res) => {
  try {
    const booking = await bookingService.createBooking(req.body);
    res.status(201).json(booking);
  } catch (error) {
    console.error('Error creating booking:', error);
    res.status(500).json({
      error: 'Failed to create booking',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Booking request endpoint (matches frontend expectation)
app.post('/api/bookings/request', async (req, res) => {
  try {
    const bookingRequest = req.body;
    
    // Convert BookingRequest to Booking format
    const booking = {
      coupleId: bookingRequest.coupleId,
      vendorId: bookingRequest.vendorId,
      serviceType: bookingRequest.serviceType,
      eventDate: new Date(bookingRequest.eventDate),
      status: 'pending' as const,
      totalAmount: 0, // Will be set by vendor
      notes: bookingRequest.specialRequests || '',
      // Additional booking request data
      serviceName: bookingRequest.serviceName || bookingRequest.serviceType,
      eventTime: bookingRequest.eventTime,
      eventLocation: bookingRequest.eventLocation,
      guestCount: bookingRequest.guestCount,
      budgetRange: bookingRequest.budgetRange,
      contactPhone: bookingRequest.contactPhone,
      preferredContactMethod: bookingRequest.preferredContactMethod
    };
    
    const createdBooking = await bookingService.createBookingRequest(booking);
    
    res.status(201).json({
      booking: createdBooking,
      success: true,
      message: 'Booking request submitted successfully'
    });
  } catch (error) {
    console.error('Error creating booking request:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create booking request',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get bookings by couple ID
app.get('/api/bookings/couple/:coupleId', async (req, res) => {
  try {
    const { coupleId } = req.params;
    const { page = 1, limit = 10, status } = req.query;
    
    const bookings = await bookingService.getBookingsByCouple(
      coupleId, 
      parseInt(page as string), 
      parseInt(limit as string),
      status as string
    );
    
    res.json({
      bookings: bookings.bookings,
      pagination: bookings.pagination,
      success: true
    });
  } catch (error) {
    console.error('Error fetching couple bookings:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch bookings',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Check existing booking for a service
app.get('/api/bookings/check', async (req, res) => {
  try {
    const { coupleId, vendorId, serviceId } = req.query;
    
    if (!coupleId || !serviceId) {
      return res.status(400).json({
        success: false,
        hasBooking: false,
        error: 'coupleId and serviceId are required'
      });
    }
    
    const booking = await bookingService.getExistingBooking(
      coupleId as string, 
      serviceId as string
    );
    
    res.json({
      hasBooking: !!booking,
      booking: booking || null,
      success: true
    });
  } catch (error) {
    console.error('Error checking existing booking:', error);
    res.status(500).json({
      success: false,
      hasBooking: false,
      error: 'Failed to check booking',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});


// Debug endpoint to check users table structure
app.get('/api/debug/users-schema', async (req, res) => {
  try {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'This endpoint is not available in production' });
    }
    
    // Check users table structure
    const columns = await db.executeQuery`
      SELECT column_name, data_type, is_nullable 
      FROM information_schema.columns 
      WHERE table_name = 'users'
      ORDER BY ordinal_position
    `;
    
    res.json({ columns });
  } catch (error) {
    console.error('Error checking users schema:', error);
    res.status(500).json({
      error: 'Failed to check users schema',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Debug endpoint to check users
app.get('/api/debug/users', async (req, res) => {
  try {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'This endpoint is not available in production' });
    }
    
    const users = await db.executeQuery`
      SELECT id, email, first_name, last_name, user_type FROM users LIMIT 10
    `;
    
    res.json({ users });
  } catch (error) {
    console.error('Error checking users:', error);
    res.status(500).json({
      error: 'Failed to check users',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get full schema for debugging
app.get('/api/debug/full-schema', async (req, res) => {
  try {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'This endpoint is not available in production' });
    }
    
    const [conversationsSchema, messagesSchema] = await Promise.all([
      db.executeQuery`
        SELECT column_name, data_type, is_nullable 
        FROM information_schema.columns 
        WHERE table_name = 'conversations'
        ORDER BY ordinal_position
      `,
      db.executeQuery`
        SELECT column_name, data_type, is_nullable 
        FROM information_schema.columns 
        WHERE table_name = 'messages'
        ORDER BY ordinal_position
      `
    ]);
    
    res.json({ 
      conversations: conversationsSchema,
      messages: messagesSchema 
    });
  } catch (error) {
    console.error('Error checking schema:', error);
    res.status(500).json({
      error: 'Failed to check schema',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Debug endpoint to check conversations table structure
app.get('/api/debug/conversations-schema', async (req, res) => {
  try {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'This endpoint is not available in production' });
    }
    
    // Check conversations table structure
    const columns = await db.executeQuery`
      SELECT column_name, data_type, is_nullable 
      FROM information_schema.columns 
      WHERE table_name = 'conversations'
      ORDER BY ordinal_position
    `;
    
    res.json({ columns });
  } catch (error) {
    console.error('Error checking conversations schema:', error);
    res.status(500).json({
      error: 'Failed to check conversations schema',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Debug endpoint to check messages table structure
app.get('/api/debug/messages-schema', async (req, res) => {
  try {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'This endpoint is not available in production' });
    }
    
    // Check messages table structure
    const columns = await db.executeQuery`
      SELECT column_name, data_type, is_nullable 
      FROM information_schema.columns 
      WHERE table_name = 'messages'
      ORDER BY ordinal_position
    `;
    
    res.json({ columns });
  } catch (error) {
    console.error('Error checking messages schema:', error);
    res.status(500).json({
      error: 'Failed to check messages schema',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Debug endpoint to check database tables (development only)
app.get('/api/debug/tables', async (req, res) => {
  try {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'This endpoint is not available in production' });
    }
    
    // Check what tables exist
    const tables = await db.executeQuery`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public'
    `;
    
    res.json({ tables });
  } catch (error) {
    console.error('Error checking tables:', error);
    res.status(500).json({
      error: 'Failed to check tables',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Database initialization endpoint (for development)
app.post('/api/admin/init-db', async (req, res) => {
  try {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'This endpoint is not available in production' });
    }
    
    await db.initializeTables();
    res.json({ message: 'Database tables initialized successfully' });
  } catch (error) {
    console.error('Error initializing database:', error);
    res.status(500).json({
      error: 'Failed to initialize database',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Test login endpoint (development only)
app.post('/api/debug/test-login', async (req, res) => {
  try {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'This endpoint is not available in production' });
    }
    
    // Return user 1-2025-001 who has conversations
    const user = {
      id: '1-2025-001',
      email: 'couple1@gmail.com',
      firstName: 'John',
      lastName: 'Smith',
      role: 'couple'
    };
    
    res.json({ user, token: 'test-token' });
  } catch (error) {
    console.error('Error with test login:', error);
    res.status(500).json({
      error: 'Failed to test login',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Debug endpoint to check conversations data
app.get('/api/debug/conversations', async (req, res) => {
  try {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'This endpoint is not available in production' });
    }
    
    // Get all conversations
    const conversations = await db.executeQuery`
      SELECT * FROM conversations ORDER BY created_at DESC
    `;
    
    res.json({ conversations });
  } catch (error) {
    console.error('Error checking conversations:', error);
    res.status(500).json({
      error: 'Failed to check conversations',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Debug endpoint to fix message sender IDs
app.post('/api/debug/fix-message-senders', async (req, res) => {
  try {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'This endpoint is not available in production' });
    }
    
    // Get all vendor users
    const vendors = await db.executeQuery`
      SELECT id, first_name, last_name FROM users WHERE user_type = 'vendor'
    `;
    
    if (vendors.length === 0) {
      return res.json({ message: 'No vendors found' });
    }
    
    // Update messages with sender_id = 'system' to use actual vendor IDs
    let updatedCount = 0;
    for (const vendor of vendors) {
      const vendorName = `${vendor.first_name} ${vendor.last_name}`;
      
      // Update a few messages for each vendor
      const updateResult = await db.executeQuery`
        UPDATE messages 
        SET sender_id = ${vendor.id}, 
            sender_name = ${vendorName},
            sender_type = 'vendor'
        WHERE sender_id = 'system' 
        AND id IN (
          SELECT id FROM messages 
          WHERE sender_id = 'system' 
          LIMIT 2
        )
      `;
      
      updatedCount += updateResult.rowCount || 0;
    }
    
    res.json({ 
      message: `Updated ${updatedCount} messages with proper sender IDs`,
      vendorsProcessed: vendors.length
    });
  } catch (error) {
    console.error('Error fixing message senders:', error);
    res.status(500).json({
      error: 'Failed to fix message senders',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Debug endpoint to check message sender IDs
app.get('/api/debug/message-senders', async (req, res) => {
  try {
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({ error: 'This endpoint is not available in production' });
    }
    
    // Get all unique sender IDs and their counts
    const senders = await db.executeQuery`
      SELECT sender_id, sender_name, sender_type, COUNT(*) as message_count
      FROM messages 
      GROUP BY sender_id, sender_name, sender_type
      ORDER BY message_count DESC
    `;
    
    res.json({ senders });
  } catch (error) {
    console.error('Error checking message senders:', error);
    res.status(500).json({
      error: 'Failed to check message senders',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Debug endpoint to check enum types
app.get('/api/debug/enum-types', async (req, res) => {
  try {
    const enumTypes = await db.neonSql`
      SELECT 
        t.typname as enum_name,
        e.enumlabel as enum_value
      FROM pg_type t 
      JOIN pg_enum e ON t.oid = e.enumtypid  
      JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
      WHERE n.nspname = 'public'
      ORDER BY t.typname, e.enumsortorder
    `;
    
    // Group enum values by type name
    const enumsByType = enumTypes.reduce((acc: any, row: any) => {
      if (!acc[row.enum_name]) {
        acc[row.enum_name] = [];
      }
      acc[row.enum_name].push(row.enum_value);
      return acc;
    }, {});
    
    res.json({ enumTypes: enumsByType });
  } catch (error) {
    console.error('Error fetching enum types:', error);
    res.status(500).json({
      error: 'Failed to fetch enum types',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Error handling middleware
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Unhandled error:', err);
  res.status(500).json({
    error: 'Internal server error',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Something went wrong'
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Endpoint not found' });
});

// Start server
const startServer = async () => {
  try {
    // Test database connection
    const dbConnected = await testDatabaseConnection();
    if (!dbConnected) {
      console.warn('âš ï¸  Database connection failed, but server will start anyway');
    }

    app.listen(PORT, () => {
      console.log(`ðŸš€ Wedding Bazaar API Server running on port ${PORT}`);
      console.log(`ðŸ“Š Health check: http://localhost:${PORT}/api/health`);
      console.log(`ðŸª Vendors API: http://localhost:${PORT}/api/vendors`);
      console.log(`ðŸ“… Bookings API: http://localhost:${PORT}/api/bookings`);
      console.log(`ðŸŒ Environment: ${process.env.NODE_ENV || 'development'}`);
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
};

// Handle graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully');
  process.exit(0);
});

// Start the server (ES module version)
startServer();

export default app;
